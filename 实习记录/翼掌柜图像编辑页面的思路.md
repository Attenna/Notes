# 需求分析：
我们能产生的图像需要至少达到以下程度，目前来说，已经可以生成ai图片，嵌入文字，叠放图片。
![[Pasted image 20250731171526.png|300]]
软件已经实现了上传用户自定义素材，和增加文字描述的基础功能
![[1bd42d23c7359cdcd78d2cc7b3a49625.png|300]]
但是，目前来说，文字没法修改大小，字重，字体，有时候ai生成的构图并不合理，需要调节（如例图，例图的洗衣机被放置在了左侧）

因此，我们对于字体嵌入，需要添加大小，字重，字体选项；对于ai生成的构图，需要调用扩图接口，擦除接口，改写接口（后两者是同一个接口）

不过我不知道开发规范，所以就先瞎写了
# 思路：
## Main
使用main.html作为主页面，主页面包括了子节点容器（godot的思想），底部栏容器，按钮。
使用main.js（反正是个什么后端语言）作为主界面的后端。它负责调用main.html引用了哪些子节点。

## 子节点
子节点实现子功能。
### 贴纸（stickers）（幻想中）
调用微信的表情包api（应该有的），然后如法炮制上传本地图片作为贴纸的代码就可以了。

### 上传本地图片作为贴纸（upload logo）（已经实现）
上传本地图片作为贴纸，已经实现了。
实现方法：定义一个结构体（对象），
结构体包含：贴纸的图像数据，贴纸的位置，贴纸的“层数”，贴纸的旋转方向，贴纸的长，宽。
用户可以任意的添加结构体。
贴纸的交互控件
每次工作读取所有结构体，放置在画布上。
点击保存按钮，再把所有结构体画在图像上。
### 嵌入文字（embedding texts）（已经实现）
嵌入文字也已经实现了。
生成一个矢量文本框，然后可以对矢量文本框进行旋转，移动，缩放，改色功能。
### AI图像抹除（ai eliminate）（幻想中）
ai图像抹除已经基本实现了
### AI局部重绘（ai regenerate）（幻想中）
ai局部重绘和ai图像抹除是同一个api，改改post请求参数就可以了
### AI扩图（ai expand）（幻想中）
这个api不一样，修改构图还是比较重要，有必要做。

# 实现方法：
## 怎么让html引用子节点（其它html）？

>_ai回答的_

在 HTML 中直接引用其他 HTML 文件（子节点）可以通过以下几种常用方法实现：

---

### 方法 1：使用 `<iframe>`（简单但内容隔离）
```html
<iframe src="header.html" width="100%" height="100px"></iframe>
```
**特点**：
- 内容独立（样式/脚本不共享）
- 需手动调整高度（可用 JS 动态调整）

---

### 方法 2：JavaScript 动态加载（推荐）
使用 `fetch()` 或 `XMLHttpRequest` 加载 HTML 内容并插入 DOM：

```html
<div id="header-container"></div>

<script>
  // 动态加载 header.html
  fetch('header.html')
    .then(response => response.text())
    .then(html => {
      document.getElementById('header-container').innerHTML = html;
    })
    .catch(error => console.error('加载失败:', error));
</script>
```

---

### 方法 3：HTML5 Web Components（现代标准）
使用 `<template>` 和 `<slot>` 创建可重用组件：

**1. 定义模板组件 (component.html)**
```html
<template id="my-header">
  <header>
    <h1>网站标题</h1>
    <slot name="subtitle">默认副标题</slot>
  </header>
</template>
```

**2. 在主文件中使用**
```html
<!-- 引入组件 -->
<link rel="import" href="component.html" id="header-template">

<!-- 使用自定义元素 -->
<my-header>
  <span slot="subtitle">自定义副标题</span>
</my-header>

<script>
  // 注册自定义组件
  const template = document.querySelector('#header-template').import;
  const headerTemplate = template.querySelector('#my-header');
  
  customElements.define('my-header', class extends HTMLElement {
    constructor() {
      super();
      const shadow = this.attachShadow({mode: 'open'});
      shadow.appendChild(headerTemplate.content.cloneNode(true));
    }
  });
</script>
```

---

### 方法 4：服务端包含（需服务器支持）
**Apache 示例 (启用 SSI)**：
```html
<!-- 直接引入子文件 -->
<!--#include virtual="header.html" -->
```
**要求**：
- 文件需以 `.shtml` 结尾
- 服务器开启 SSI 功能

---

### 方法 5：构建工具预处理（工程化方案）
使用 Webpack/Parcel 等工具的 HTML 插件：
```javascript
// Webpack 配置示例 (使用 html-webpack-plugin)
plugins: [
  new HtmlWebpackPlugin({
    template: "./src/index.html",
    chunks: ["main"]
  }),
  new HtmlWebpackPlugin({
    filename: "header.html",
    template: "./src/parts/header.html"
  })
]
```

---

### ⚠️ 注意事项
1. **跨域问题**：动态加载时需确保同源（或配置 CORS）
2. **SEO 影响**：JS 动态加载的内容可能不被搜索引擎索引
3. **性能**：小文件推荐内联，大文件考虑缓存
4. **框架方案**：
   - React/Vue/Angular 有专用组件系统
   - PHP/JSP 等后端语言原生支持 `include()`

---

### 示例目录结构
```
project/
├── index.html
├── components/
│   ├── header.html
│   └── footer.html
└── scripts/
    └── load-components.js
```

根据项目需求选择最适合的方案，小型项目推荐 **JS 动态加载**，大型应用推荐 **Web Components** 或 **构建工具集成**。
## 和后端怎么通信？

## 后端脚本之间需要通信吗？

大概是需要的。

>以下为ai生成
### Python Flask 后端脚本间通信实现方式

最简单的是使用数据库。
在 Flask 后端应用中，有几种常见的方式可以实现不同脚本或组件之间的通信：

#### 1. 模块导入与函数调用

最简单直接的方式是通过 Python 的模块导入机制：

```python
# script_a.py
def some_function():
    return "Hello from script A"

# script_b.py
from script_a import some_function

result = some_function()
```

#### 2. 使用 Flask 的请求上下文

对于需要 HTTP 接口通信的情况：

```python
# service_a.py
from flask import Flask
app = Flask(__name__)

@app.route('/api')
def api_endpoint():
    return {"message": "Hello from Service A"}

# service_b.py
import requests

response = requests.get('http://localhost:5000/api')
print(response.json())
```

#### 3. 消息队列 (RabbitMQ, Redis等)

对于异步或解耦的通信：

```python
# producer.py
import pika

connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()
channel.queue_declare(queue='hello')

channel.basic_publish(exchange='', routing_key='hello', body='Hello from Producer!')

# consumer.py
import pika

def callback(ch, method, properties, body):
    print(f"Received {body}")

connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()
channel.queue_declare(queue='hello')
channel.basic_consume(queue='hello', on_message_callback=callback, auto_ack=True)
channel.start_consuming()
```

#### 4. 使用数据库作为中介

```python
# writer.py
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()

class Message(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    content = db.Column(db.String(200))

# 写入消息
new_msg = Message(content="Hello from Writer")
db.session.add(new_msg)
db.session.commit()

# reader.py
from models import Message

messages = Message.query.all()
for msg in messages:
    print(msg.content)
```

#### 5. 使用 Python 内置队列

```python
# shared_queue.py
from queue import Queue

message_queue = Queue()

# producer.py
from shared_queue import message_queue

message_queue.put("Message 1")

# consumer.py
from shared_queue import message_queue

msg = message_queue.get()
print(msg)
```

#### 6. 使用 Flask 的蓝图(Blueprint)组织代码

对于大型应用，可以使用蓝图组织不同模块：

```python
# api/__init__.py
from flask import Blueprint

api = Blueprint('api', __name__)

from . import routes

# api/routes.py
from . import api

@api.route('/endpoint')
def endpoint():
    return {"status": "success"}
```

#### 选择哪种方式取决于你的具体需求：
- 简单同步通信：模块导入或函数调用
- 需要 HTTP 接口：Flask 路由
- 异步或解耦：消息队列
- 数据持久化：数据库
- 进程间通信：队列或消息代理