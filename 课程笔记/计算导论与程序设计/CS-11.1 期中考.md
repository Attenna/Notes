## 6-1 数制
**记数**是人类用来表示和计算数量的基本方法。在记数过程中，我们通常使用一系列有序的符号或数字来表示数量。这些符号或数字可以是简单的（如手指计数），也可以是复杂的（如现代数学中的数字系统）。这里有一个非常重要的概念就是**数制**。数制中表示数值大小的那些固定的数字符号称为**数码**。每种数制所使用数码的个数称为该进制数的**基数**。比如十进制的基数为10，二进制的基数为2。一个数码处在不同位置上所代表的值不 同，每个数码所表示的数值等于该数码乘以一个与数码所在位置相关的常数，这个常数叫做**位权**。位权的大小是以该数制的基数为底、数码所在位置的序号为指数的整数次幂。例如：二进制数101，左边的数码1的位权是22，中间的数码0的位权是21，右边的数码1的位权是20。十进制数12.1，小数点前面的数码1的位权是101，数码2的位权是100，小数点后面的数码1的位权是10−1。  
事实上对于任意一个R进制数都可以表示为该数制的数码与基数的幂次的乘积之和，即对任意的R进制数an−1​an−2​…a1​a0​a−1​a−2​…a−m​，都可以表示成按位权展开的多项式之和的形式：an−1​×Rn−1+an−2​×Rn−2+…+a1​×R1+a0​×R0+a−1​×R−1+a−2​×R−2+…+a−m​×R−m。其中，R是数制的基数，ai​ (i = -m,…,-2,-1,0,1.,…,n-1) 为该数制的数码，n为该R进制数的整数部分的位数，m为小数部分的位数。  
尽管不同进制在表示数值时使用的数字和进位规则不同，但它们都可以表示相同的数值范围，只是表示方式和长度不同。因此，在理论上讲，各种进制是等价的。  
现给定十进制正整数，和一个进制的基数（10进制表示），请你写一个函数将这个正整数变为该进制的数码与基数的幂次的乘积之和。

### 输入：  
第一行为一个整数T（0<T<100），代表共T组测试用例。后边是T行，每行均为两个用一个空格分隔的整数，依次代表待处理十进制整数n(0<n<100000000)，和基数base(1<base<100)。测试用例保证合法。  
### 输出：  
若干行，每组测试用例的格式都是一样的，先输出测试用例的序号（见输出样例），然后幂次从小到大的顺序输出多项式中每一项的数码和权值（用一个空格分隔），每行输出一项（具体见输出样例），如果数码为0，则不输出该项。  
### 样例解释：  
第一组测试用例，10进制整数12345可以表示为 5×100+4×101+3×102+2×103+1×104 ，即 12345 = 5 + 40 + 300 + 2000 + 10000 。  
第二组测试用例，10进制整数12345可以表示为 1×20+1×23+1×24+1×25+1×212+1×213 （1 ，2，6，7，8 ，9 ，10，11次幂所乘的数码均为0，所以没有输出）， 即12345 = 1 + 8 + 16 + 32 + 4096 + 8192 。（特别的，由于二进制的数码只有0和1两个，因此任意一个正整数都可以惟一的表示为若干个2的幂次之和。）

### 函数接口定义：

```c++
void    printBasePower( int number , int base ) ;
```

其中 `number` 和 `base` 都是用户传入的参数。`number` 代表待处理10进制正整数； `base` 是进制的基数。函数没有返回值，但要按要求输出结果。

### 裁判测试程序样例：

```c++
#include <stdio.h>

void    printBasePower( int number , int base ) ;

int main()
{
    int        i , T , n , base ;
    
    scanf( "%d" , &T ) ;
    for ( i = 1 ; i <= T ; i++ )
    {
        scanf( "%d%d" ,  &n , &base ) ;
        printf("Test Cases %d :\n" , i ) ;
        printBasePower( n , base ) ;
    }
    
    return 0;
}

/* 请在这里填写答案 */
```

### 输入样例：

```in
2
12345 10
12345 2
```

### 输出样例：

```out
Test Cases 1 :
5 1
4 10
3 100
2 1000
1 10000
Test Cases 2 :
1 1
1 8
1 16
1 32
1 4096
1 8192
```

答案:
```c
#include <stdio.h>
#include <math.h>
void printBasePower(int number, int base){
	int(power = 0){
		int digit = number % base;
		if(digit != 0)
			printf("%d %d\n",digit,(int)pow(base,power));
		}
		number /= base;
		power ++;
}
```
```c
#include <stdio.h>
//无math库版本
void printBasePower(int number, int base) {
    int power = 0;
    int current_base_power = 1; // base^0 = 1
    while (number > 0) {
        int digit = number % base;
        if (digit != 0) {
            printf("%d %d\n", digit, current_base_power);
        }
        number /= base;
        power++;
        current_base_power *= base; // 计算 base 的下一个幂次
    }
}
```
## 7-1 回文数二

输入任意整数，设计一个回文数判定算法，判定并输出该数是否为回文数？

### 输入格式:

只有一行，为两个用空格分隔的正整数num及len。它们分别代表输入的整数及其长度（0<len<10）。

### 输出格式:

前边若干行按比较顺序依次输出每行为参与比较的两个数（中间有一个空格），高位在前，低位在后。如果len为奇数，最后一次只有一个数字时，则将该数字输出2次。如果没有比较完就已知道不是回文数，要停止比较，后边的比较过程没有了，也就没有相应的输出。  
最后一行：如果是回文数则输出Yes，否则输出No。

### 输入样例一:

```in
121 3
```

### 输出样例一:

```out
1 1
2 2
Yes
```

### 输入样例二:

```in
1234 4
```

### 输出样例二:

```out
1 4
No
```

### 答案：
```c
#include <stdio.h>
  
int power(int base, int exponent) {
	int result = 1;
	for (int i = 0; i < exponent; i++) {
		result *= base;
	}
	return result;
}

void compare(int number,int len){
	for(i = 0;i<= len/2;i++){
		int x = power(10,i);
		
	}
}
int main(){
	int a,b；
	scanf("%d";a,b);
	void compare(&a,&b);
	
}
```