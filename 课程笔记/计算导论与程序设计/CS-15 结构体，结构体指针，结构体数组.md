# 结构体

结构体是一个用来把不同类型的数据打包的一个数据结构。比如一个学生的学号 (char)，姓名 (char)，年龄 (int) 等。结构体的作用是为了“打包”数据，让数据变得有关联。

## 结构体的两种定义方式

```c
typedef struct {
    int aaa;
    int bbb;
    char ccc;
} Name1;

Name1 Name2;
```

```c
struct Name1 {
    int aaa;
    int bbb;
    char ccc;
};

struct Name1 Name2;
```

## `typedef` 和 `struct` 的区别

`typedef` 和 `struct` 是 C 语言中用于定义数据类型的关键字，但它们的用途和功能有所不同。

### `struct`

- `struct` 用于定义结构体类型。结构体是一种用户定义的数据类型，它允许你将不同类型的数据组合在一起。
- 定义结构体时，你需要使用 `struct` 关键字。

例如：

```c
struct Date {
    int year;
    int month;
    int day;
};
```

使用结构体时，你需要使用 `struct` 关键字：

```c
struct Date birth;
```

### `typedef`

- `typedef` 用于为现有的数据类型创建一个新的类型名。它通常用于简化类型声明，使代码更易读。
- `typedef` 可以与 `struct` 结合使用，为结构体类型创建一个简化的名称。

例如：

```c
typedef struct {
    int year;
    int month;
    int day;
} Date;
```

使用 `typedef` 后，你可以直接使用 `Date` 来声明变量，而不需要每次都写 `struct Date`：

```c
Date birth;
```

在你的代码中，`typedef` 和 `struct` 结合使用，为结构体类型创建了一个简化的名称 `Date`。以下是你的代码的完整示例：

```c
#include <stdio.h>

int main() {
    typedef struct {
        int year;
        int month;
        int day;
    } Date;
    
    Date birth;
    birth.year = 1990;
    birth.month = 1;
    birth.day = 1;    

    printf("%d\n", birth.year);
    printf("%d\n", birth.month);
    printf("%d\n", birth.day);
    return 0;
}
```

在这个示例中，`typedef` 和 `struct` 结合使用，使得你可以直接使用 `Date` 来声明变量，而不需要每次都写 `struct Date`。这使得代码更加简洁和易读。

---

## 例题 1

以下对字符串的操作正确的是：

```c
char* msg1 = "Good Morning!";
char msg2[] = "Good Morning!";
```

A. `msg2[4] = '_';`

B. `int i = 0; while( msg1[i++] == msg2[i++] ) { }`

C. `msg1[4] = '_';`

D. `while( *msg1++ == *msg2++ ) { }`

### 分析

- **A**: `msg2` 是字符数组，可以直接修改。
- **B**: 错误，`msg1` 和 `msg2` 比较会导致数组越界，因为 `i++` 会在比较后递增，最终会访问到未定义的内存区域。
- **C**: 错误，`msg1` 是个指针，字符串字面值是不可修改的。
- **D**: 错误，同 B。

---

## 例题 2

箭头操作符（`->`）用于通过指针访问结构体或联合体的成员。它结合了解引用和成员访问操作，简化了代码的书写。

例如，假设有一个指向结构体的指针 `ptr`，并且该结构体有一个成员 `member`，那么可以使用箭头操作符 `ptr->member` 来访问该成员。这相当于 `(*ptr).member`，但更简洁。

以下是一个简单的示例：

```c
typedef struct {
    int year;
    int month;
    int day;
} Date;

Date myDate;
Date *ptr = &myDate;

ptr->year = 2025;  // 使用箭头操作符访问并修改 year 成员
```

在这个例子中，`ptr->year` 访问并修改了 `myDate` 结构体的 `year` 成员。

---

## 例题 3

```c
typedef struct {
    int month;
    int day;
    int year;
} Date;

Date myBirthList[5];
```

以下对这一结构体数组内参数访问正确的是：

A. `myBirthList->year`

B. `*myBirthList.year`

C. `(*(myBirthList+1)).year`

D. `myBirthList[0].year`

E. `(myBirthList+1)->year`

F. `*(myBirthList+1).year`

### 分析

- **A**: 错误。`myBirthList` 是一个数组名，不能直接使用箭头操作符访问其成员。
- **B**: 错误。`myBirthList.year` 不是一个有效的表达式，不能使用解引用操作符。
- **C**: 正确。`myBirthList+1` 是数组的第二个元素的地址，解引用后可以访问其成员 `year`。
- **D**: 正确。可以直接使用数组下标访问第一个元素的成员 `year`。
- **E**: 正确。`myBirthList+1` 是数组的第二个元素的地址，可以使用箭头操作符访问其成员 `year`。
- **F**: 错误。`(myBirthList+1).year` 不是一个指针，不能使用解引用操作符。

---

## 例题 4

`Date myBirthList[5]` 的含义是定义一个包含 5 个 `Date` 结构体元素的数组。每个元素都是一个 `Date` 结构体，包含 `year`、`month` 和 `day` 三个成员。

具体来说：

- `myBirthList` 是一个数组名。
- `[5]` 表示数组的大小，即数组中有 5 个 `Date` 结构体。
- 每个 `Date` 结构体都有 `year`、`month` 和 `day` 三个成员。

---

# R7-1 计算导论13：结构体

编写一个程序，录入班级中各个同学的成绩，并按照学号排序、格式化打印输出。

### 输入格式

输入学生的个数 n，然后输入学生信息。其中每行一名学生信息记录，输入 n 行。

学生的信息包括：学号（int，如 202401），成绩1（float），成绩2（float），姓名（字符串，如 Michael Li，长度不超过 20 字符），各个字段之间用一个空格分隔。

### 输出格式

1. 按照 “学号 姓名 成绩1 成绩2” 的格式输出每名学生的信息，其中成绩要求保留 2 位小数。
2. 要按照学号从低到高顺序输出。
3. 字段之间用一个空格分隔。

### 输入样例

例如：

```c
2
202402 99.1 90.2 Michael Li
202401 88.2 85.1 Lee
```

### 输出样例

例如：

```c
202401 Lee 88.20 85.10
202402 Michael Li 99.10 90.20
```

### 示例代码

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 定义学生信息的结构体
struct Student {
    int number;
    float grade1;
    float grade2;
    char name[21];
};

// 比较函数，用于 qsort 按学号排序
int compare(const void *a, const void *b) {
    return ((struct Student *)a)->number - ((struct Student *)b)->number;
}

// 输入学生信息
void getinput(struct Student *students, int n) {
    for (int i = 0; i < n; i++) {
        scanf("%d %f %f %[^\n]", &students[i].number, &students[i].grade1, &students[i].grade2, students[i].name);
    }
}

int main() {
    int n;
    scanf("%d", &n);

    // 动态分配学生数组
    struct Student *students = (struct Student *)malloc(n * sizeof(struct Student));
    if (students == NULL) {
        printf("Memory allocation failed\n");
        return 1;
    }

    // 获取输入
    getinput(students, n);

    // 按学号排序
    qsort(students, n, sizeof(struct Student), compare);

    // 输出学生信息
    for (int i = 0; i < n; i++) {
        printf("%d %s %.2f %.2f\n", students[i].number, students[i].name, students[i].grade1, students[i].grade2);
    }

    // 释放动态分配的内存
    free(students);

    return 0;
}
```