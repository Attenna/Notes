#未提交 #dp #编程 
## 题目描述

帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 $n \times m$ 的矩阵，矩阵中的每个元素 $a_{i,j}$ 均为非负整数。游戏规则如下：

1. 每次取数时须从每行各取走一个元素，共 $n$ 个。经过 $m$ 次后取完矩阵内所有元素；
2. 每次取走的各个元素只能是该元素所在行的行首或行尾；
3. 每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值 $\times 2^i$，其中 $i$ 表示第 $i$ 次取数（从 $1$ 开始编号）；
4. 游戏结束总得分为 $m$ 次取数得分之和。

帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。

## 输入格式

输入文件包括 $n+1$ 行：

第一行为两个用空格隔开的整数 $n$ 和 $m$。

第 $2\sim n+1$ 行为 $n \times m$ 矩阵，其中每行有 $m$ 个用单个空格隔开的非负整数。

## 输出格式

输出文件仅包含 $1$ 行，为一个整数，即输入矩阵取数后的最大得分。

## 输入输出样例 #1

### 输入 #1

```
2 3
1 2 3
3 4 2
```

### 输出 #1

```
82
```

## 说明/提示

**【数据范围】**

对于 $60\%$ 的数据，满足 $1\le n,m\le 30$，答案不超过 $10^{16}$。  
对于 $100\%$ 的数据，满足 $1\le n,m\le 80$，$0\le a_{i,j}\le1000$。

**【题目来源】**

NOIP 2007 提高第三题。

## 读题：
对于矩阵的每一行，分别做dp。dp只在行里。由于答案不超过$10^6$，所以得做大数运算
### 状态：
对于每一次操作，只能在两端。首先我们定义区间`[0,n]`则，我们最终取数会取到中间区间为`0`，两端的区间并为`[0,n]`且交为$\varnothing$。
#### 状态转移方程：
假设$dp[i][j]$是dp到了区间$[i,j]$的时候的已经得了的分数
则
$$
初始条件： f[i][j] = a[i] \times2^m
$$
$$
f[i][j]=max(f[i+1][j])+a[k][i]∗2m+i−j,f[i][j−1]+a[k][j]∗2m+i−j)
$$
# 题解
## 题目大意

> 有一个n×m的矩阵，对于第i行，每次**取走**边缘的值Ai,j​，增加这一行的得分x~~(自行看题目规则)~~，求n行的最大得分总和。

## 分析一下

- 求n行最大得分和，每一行取数又不会影响到其他行，那么只要确保每一行得分最大，管好自家孩子就行了。（这个在动规中叫**最优子结构**）
- 每次取数是在边缘取，那么每次取数完剩下来的元素一定是在一个完整的一个区间中，又是求最优解，**区间DP**应运而生。

## DP流程

(每次DP仅针对第T行)

### 状态

- 我们用fi,j​表示区间**变为**[i,j]时，获得的最大分数。

### 转移

- 当区间变为[i,j]时，上一次取数的时候区间一定是[i−1,j]或[i,j+1]，从这两个状态转移即可。在第m−j+i−1次(这个请自行模拟)取走了Ai−1,j​或Ai,j+1​即：fi,j​=max{fi−1,j​+Ai−1,j​⋅2m−j+i−1,fi,j+1​+Ai,j+1​⋅2m−j+i−1}

### 终值（答案）

- 啊这个终值超级讨厌，状态不明确的话还真想不出来。
- 因为题目中说要取完，但是空区间是DP不出来的，然后就得手动模拟每个长度为1的区间。即：

Ans=maxi≤m​{fi,i​+Ai,i​⋅2m}

---

## 一些~~(超级烦的)~~事情

- 我就不说为什么要用**高精度**了⋯
- 啊高精度好烦的⋯
- 烦归烦我又有什么办法呢，我又不会int128⋯

#### 总结一下要用的所有高精度

1. 高精+高精
    
2. 高精×单精
    
3. max{高精,高精}(手动调皮)
    

#### 好了我不管你们想粘板子就粘板子吧⋯

---

## 代码君

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>

using namespace std;

const int MAXN = 85, Mod = 10000; //高精四位压缩大法好 
int n, m;
int ar[MAXN];

struct HP {
	int p[505], len;
	HP() {
		memset(p, 0, sizeof p);
		len = 0;
	} //这是构造函数，用于直接创建一个高精度变量 
	void print() {
		printf("%d", p[len]);  
        for (int i = len - 1; i > 0; i--) {  
            if (p[i] == 0) {
				printf("0000"); 
				continue;
			}
            for (int k = 10; k * p[i] < Mod; k *= 10) 
				printf("0");
            printf("%d", p[i]);
        }
	} //四位压缩的输出 
} f[MAXN][MAXN], base[MAXN], ans;

HP operator + (const HP &a, const HP &b) {
	HP c; c.len = max(a.len, b.len); int x = 0;
	for (int i = 1; i <= c.len; i++) {
		c.p[i] = a.p[i] + b.p[i] + x;
		x = c.p[i] / Mod;
		c.p[i] %= Mod;
	}
	if (x > 0)
		c.p[++c.len] = x;
	return c;
} //高精+高精 

HP operator * (const HP &a, const int &b) {
	HP c; c.len = a.len; int x = 0;
	for (int i = 1; i <= c.len; i++) {
		c.p[i] = a.p[i] * b + x;
		x = c.p[i] / Mod;
		c.p[i] %= Mod;
	}
	while (x > 0)
		c.p[++c.len] = x % Mod, x /= Mod;
	return c;
} //高精*单精 

HP max(const HP &a, const HP &b) {
	if (a.len > b.len)
		return a;
	else if (a.len < b.len)
		return b;
	for (int i = a.len; i > 0; i--)
		if (a.p[i] > b.p[i])
			return a;
		else if (a.p[i] < b.p[i])
			return b;
	return a;
} //比较取最大值 

void BaseTwo() {
	base[0].p[1] = 1, base[0].len = 1;
	for (int i = 1; i <= m + 2; i++){ //这里是m! m! m! 我TM写成n调了n年... 
		base[i] = base[i - 1] * 2;
	}
} //预处理出2的幂 

int main(void) {
	scanf("%d%d", &n, &m);
	BaseTwo();
	while (n--) {
		memset(f, 0, sizeof f);
		for (int i = 1; i <= m; i++)
			scanf("%d", &ar[i]);
		for (int i = 1; i <= m; i++)
			for (int j = m; j >= i; j--) { //因为终值是小区间，DP自然就从大区间开始 
				f[i][j] = max(f[i][j], f[i - 1][j] + base[m - j + i - 1] * ar[i - 1]); 
				f[i][j] = max(f[i][j], f[i][j + 1] + base[m - j + i - 1] * ar[j + 1]);
			} //用结构体重载运算符写起来比较自然 
		HP Max;
		for (int i = 1; i <= m; i++)
			Max = max(Max, f[i][i] + base[m] * ar[i]);
		ans = ans + Max; //记录到总答案中 
	}
	ans.print(); //输出 
	return 0;
}
```

作者：Jack_Homes_Huang    创建时间：2018-07-24 11:19:27