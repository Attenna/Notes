#已提交 #dp #编程 
# P1004 \[NOIP 2000 提高组] 方格取数

## 题目背景

NOIP 2000 提高组 T4

## 题目描述

设有 $N \times N$ 的方格图 $(N \le 9)$，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 $0$。如下图所示（见样例）:

![](https://cdn.luogu.com.cn/upload/image_hosting/0bpummja.png)

某人从图的左上角的 $A$ 点出发，可以向下行走，也可以向右走，直到到达右下角的 $B$ 点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 $0$）。  
此人从 $A$ 点到 $B$ 点共走两次，试找出 $2$ 条这样的路径，使得取得的数之和为最大。

## 输入格式

输入的第一行为一个整数 $N$（表示 $N \times N$ 的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的 $0$ 表示输入结束。

## 输出格式

只需输出一个整数，表示 $2$ 条路径上取得的最大的和。

## 输入输出样例 #1

### 输入 #1

```
8
2 3 13
2 6  6
3 5  7
4 4 14
5 2 21
5 6  4
6 3 15
7 2 14
0 0  0
```

### 输出 #1

```
67
```

## 说明/提示

数据范围：$1\le N\le 9$。

## 读题：
从A到B，单向，从上到下，不回头。
难点是两个。算两次dp？同时算dp？

### 转移方程：
$$
dp[s][i][k] = \max
\begin{cases}
dp[s-1][i-1][k-1], \\
dp[s-1][i-1][k], \\
dp[s-1][i][k-1], \\
dp[s-1][i][k]
\end{cases}
+ \text{value}
$$
同时算dp，不过重复的地方得变为0，总之就是少算一次。
算两条路径。
第一条走到$(i,j)$和第二条走到$(k,l)$时的最大和，$j = s-i, l = s-k$。
如果$i = k, j = l$ 则 `value = grid[i][j]`
否则，`value = grid[i][j]+grid[k][l]`
### 初始化：
初始状态 `dp[2][1][1]=grid[1][1]`，因为两条路径都在起点 `(1,1)`，步数 `s=2`。
### 最终答案：
最终结果是 `dp[2N][N][N]`，即两条路径都到达终点 `(N,N)` 时的最大和。
### 输入伪代码：
```c
scanf("%d",&n);
int dp[n][n];
int i = 0;
do{
	int x,y = 0;
	scanf("%d %d",&x,&y);
	scanf("%d",&dp[x][y]);
}
while(x,y,dp[x][y] != 0);
```
### 开始算dp：
$s = i+j = k+l$ 而其中，$j = s-i, l = s-k$
```c
for(int s = 2; s <= 2 *N; s++){
	for(int i = 1; i <= N; i++){
		for(int k = 1; k < N; k++){
			int j = s-i;
			int l = s-k;

			if (j <1 || j >N || l <1 || l> N) continue;

			int val;
			if( i == k && j == l){
				val = grid[i][j];
			}else{
				val = grid[i][j] + grid[k][l];
			}

            dp[s][i][k] = max({
                dp[s-1][i-1][k-1],
                dp[s-1][i-1][k],
                dp[s-1][i][k-1],
                dp[s-1][i][k]
            }) + val;
		}
	}

	printf("%d",dp[2*N][N][N]);
	return 0;
}
```
### 代码：
```cpp
#include <iostream>  
#include <algorithm>  
using namespace std;  
  
int main(){  
    int n =0;  
    scanf("%d",&n);  
    int N = n;  
    int dp[20][10][10] = {0};  
    int grid[10][10] = {0};  
        while (1){  
        int x,y,val;  
        cin>>x>>y>>val;  
        if(x ==0 && y==0&&val == 0) break;  
        grid[x][y] = val;  
    }  
  
        dp[2][1][1] = grid[1][1];  
        for(int s = 2; s <= 2*N; s++){  
        for(int i = 1; i <= N ; i++){  
            for(int k = 1; k <= N ; k++){  
                int j = s-i;  
                int l = s-k;  
                                if(j<1||j>N||l<1||l>N) continue;  
                                int val;  
                if(i == k && j ==l){  
                    val = grid[i][j];  
                }  
                else{  
                    val = grid[i][j] + grid[k][l];  
                }  
                                dp[s][i][k] = max({  
                    dp[s-1][i-1][k-1],  
                    dp[s-1][i-1][k],  
                    dp[s-1][i][k-1],  
                    dp[s-1][i][k]  
                }) + val;  
            }  
        }  
    }  
    cout << dp[2*N][N][N] << endl;  
    return 0;  
}
```